import { Tables } from "@/types/supabase"
import { getServerClient } from "@/lib/supabase/hook"

export type AssignmentWithAssociateAndRole = Tables<"assignments"> & {
  associate: Tables<"associates">
  role: Tables<"roles">
}

export type GroupWithAssignments = Tables<"groups"> & {
  assignments: AssignmentWithAssociateAndRole[]
}

export type ShiftPlanWithGroups = Tables<"plans"> & {
  groups: GroupWithAssignments[]
}

export type FullDateData = Tables<"dates"> & { plans?: ShiftPlanWithGroups[] }

export async function getPlan(
  date: string,
  select: string = "*, plans (*, assignment:assignments!inner (*, associate:associates!inner (*), role:roles!inner (*)))"
) {
  try {
    const supabase = getServerClient()

    if (!date) {
      throw new Error(`Date is required`)
    }

    // We try to get our data by date
    const { data: object, error } = await supabase
      .from("dates")
      .select(select)
      .eq("date", date)
      .returns<FullDateData[]>()
      .single()

    // If no date object exists, we create one along with shift plans and empty assignments
    if (!object) {
      const { data: dateData, error: dateError } = await supabase
        .from("dates")
        .insert({ date })
        .select()
        .single()

      if (dateError) throw dateError

      // Once we have created a new date, we add two shift plans. One for days and one for nights
      const { data: planData, error: planError } = await supabase
        .from("plans")
        .insert([
          { date_id: dateData.id, type: "day (1st)" },
          { date_id: dateData.id, type: "day (2nd)" },
          { date_id: dateData.id, type: "night (1st)" },
          { date_id: dateData.id, type: "night (2nd)" },
        ])
        .select()

      if (planError) throw planError

      // We setup 9 groups for the staffing assignments to be generated by default
      const groups: any[] = []
      const groupNames = [
        "16 Odd / 19 Odd",
        "16 Even / 17 Odd",
        "17 Even / 18 Odd",
        "18 Even / 21 Even",
        "19 Even / 20 Odd",
        "20 Even / 21 Odd",
        "Support",
      ]

      planData.forEach((plan) => {
        groupNames.forEach((name) => {
          groups.push({ plan_id: plan.id, name: name })
        })
      })

      const { data: groupData, error: groupError } = await supabase
        .from("groups")
        .insert(groups)
        .select()

      if (groupError) throw groupError

      // We set up empty assignments for use, several in each generated group
      const assignments: any[] = []

      groupData.forEach((group) => {
        for (let i = 0; i < 4; i++) {
          assignments.push({ group_id: group.id })
        }
      })

      const { error: assignmentsError } = await supabase.from("assignments").insert(assignments)

      if (assignmentsError) throw assignmentsError

      const { data: newDate, error: newDateError } = await supabase
        .from("dates")
        .select(select)
        .eq("id", dateData.id)
        .returns<FullDateData[]>()
        .single()

      if (newDateError) {
        console.log(`[PLAN_CREATION_ERROR]`, error)
        throw newDateError
      }

      return newDate
    }

    if (error) throw error

    return object
  } catch (error) {
    console.log(`[PLAN_GET]`, error)
    throw new Error("Internal error")
  }
}

// 6 valleys
// 6 pas / 6 tr / 4 jam clear / 2 ws
// 12+4+2 = 18

// whd, ps, support

// o16e o17e o18e
// o19e o20e o21e
